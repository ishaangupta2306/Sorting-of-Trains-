# Sorting-of-Trains-
Trains are an essential part of the transportation network. A train will have a large number of places to pick up cargo as well as a large number of places to deliver the cargo. To make the train operation more efficient, train companies have built railyards where the trains can be disassembled, cars can be sorted, and trains can be reassembled. The goal of a railyard is to separate and reorder the cars of a train so that cars that are going to the same location are together on the outgoing train. The part of a railyard used to sort the cars is called a classification yard. A classification yard consists of a collection of parallel tracks. Cars entering the classification yard can be directed to any of the parallel tracks, and when exiting the classification yard, the cars on the parallel tracks are merged together onto the single exiting track.
Classification yards can have variations in the number of parallel tracks and how they are connected. In this project, it is assumed that a classification yard has a single entrance and a single exit with a railyard to have multiple classification yards connected in serial (one after the other). Sorting train cars is quite challenging because there are a fixed number of parallel tracks in a trainyard. (Also, each track has a fixed length, but we will ignore that issue) In this project, a railyard simulation is implemented and it will run different algorithms for sorting the cars of an incoming train. Also, this project analyzes the algorithms to try to determine when one algorithm is superior to another (see the additional requirement for the JUnit tests below). A RailYard class is created to simulate a railyard. The class will take a constructor that has an array of int. The size of the array indicates the number of classification yards in the railyard, and the value of each entry in the array is the number of parallel tracks in that classification yard. For example, if the input is the array [5], then the RailYard consists of a single classification yard with five parallel tracks, and if the input is the array [4,3], then the RailYard consists of two classification yards. The first has four parallel tracks and the second has three parallel tracks.
 
Design of the Class
 
Because the number of classification yards and the number of tracks in each classification yard is fixed, an array and/or ArrayList is used to model both the classification yards and the tracks inside each yard.  Because the number of cars that will be placed on each track is undefined, and because the tracks have essentially unlimited capacity,  a linked list is used to model each track in the classification yard. In the project, the LinkedList class from the Java API has been used. 
 
To model the train, a list of objects that are Comparable, for example String or Integer, is used.  Railyard should work with any possible Comparable type. The Comparable object represents the destination for a car, and an optimal ordering of the train will be one that places the list in order. For example, if we are using Integer for the rail cars, and the train is a list in the following order: 5, 1, 3, 9, 2, we want to use the railyard to reorder the cars so that the final result is a train in the order 1, 2, 3, 5, 9.
 
 
Methods in the Railyard Class:
void cycleSort(T[] train): takes a train that is represented as an array of appropriate objects. Sorts the array (i.e. cars of the train) using the "cycle sort" algorithm described below.
void cycleSort(List<T> train): takes a train that is represented as a List (from the Java API) of appropriate objects. Sorts the list (i.e. cars of the train) using the "cycle sort" algorithm described below.
void closestSort(T[] train): takes a train that is represented as an array of appropriate objects. Sorts the array (i.e. cars of the train) using the "closest sort" algorithm described below.
void closestSort(List<T> train): takes a train that is represented as a List (from the API) of appropriate objects. Sorts the list (i.e. cars of the train) using the "closest sort" algorithm described below.
the main method. Main method for the class. The main method accepts the following command-line arguments. First is a string that is either "closest" or "cycle", the second is an integer which is the number of classification yards. Then there are a number of integers, one for each classification yard, that indicates the number of tracks. Finally, there are a bunch of strings. The main creates a rail yard with the given number of classification yards and tracks per yard, and then runs the desired sort on the input strings, and outputs the result.
For example:
java RailYard cycle 3 5 2 4 banana apple cherry pear orange pineapple blueberry peach cantalope apricot durian honeydew cranberry grapefruit watermelon dragonfruit kiwi grape quince raspberry kumquat plum should create a rail yard with three classification yards. The first has 5 parallel tracks, the second 2 parallel tracks, and the third 4 parallel tracks. It then does a cycle sort on the strings starting with "banana" and ending with "plum" and prints the final "train" ordering of those strings. The main method does not crash if the user enters bad data but instead gives a useful non-Java error message to the user.
 
Also, there are an additional 3 helper methods to avoid very long methods and lots of duplicate code. 

 
Description of Sorting Algorithms
 
Both sorting algorithms have the following structure: for each classification yard in the railyard, the train enters the classification yard, the sorting algorithm below is used to take each car, one at a time, from the front of the train and place it onto the back of the appropriate track of the classification yard. Once all cars of the train are on tracks of the classification yard, the merge algorithm is used to take each car, one by one, out of the front of the tracks of the classification yard and place the car onto the back of an initially empty train. This process repeats through each of the classification yards, in order, in the railyard. Trains may not go through classification yards out of order nor go through the same classification yard twice nor skip a classification yard.
 
Cycle Sort: When the train enters the classification yard, the first car is placed on the first track. For each following car, if the car is greater than or equal to the car that preceded it in the train, it is placed on the same track as the preceding car. If the car is smaller than the preceding car, it is placed on the next track of the classification yard, if there is a next track, and the first track if the preceding car was placed on the last track of the classification yard.
 
Closest Sort: To determine the track to place a car, we examine the cars at the back of each track. We chose the track whose back-most car is the largest car that is less than or equal to the car being placed. If there is no such track, the car is placed on an empty track, if one exists, or onto the track for which the back car has the smallest value. For example, if the back cars on the four tracks are 5, 9, 3, 7 and we are placing car 6, it is placed on the same track as 5 because that is the largest back car smaller than 6. On the other hand, if we are placing 2 we place it after 3 (assuming there are no empty tracks) because that is the track with the smallest back car.
 
Merge: Until all the tracks are empty, the front car of each track is considered and of those cars, the one with the least value is removed and is placed at the back of the train.
